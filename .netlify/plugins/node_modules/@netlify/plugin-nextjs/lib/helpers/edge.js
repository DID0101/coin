"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeEdgeFunctions = exports.writeDevEdgeFunction = exports.cleanupEdgeFunctions = exports.loadMiddlewareManifest = void 0;
/* eslint-disable max-lines */
const fs_1 = require("fs");
const path_1 = require("path");
const chalk_1 = require("chalk");
const destr_1 = __importDefault(require("destr"));
const fs_extra_1 = require("fs-extra");
const outdent_1 = require("outdent");
const config_1 = require("./config");
const matchers_1 = require("./matchers");
const loadMiddlewareManifest = (netlifyConfig) => {
    const middlewarePath = (0, path_1.resolve)(netlifyConfig.build.publish, 'server', 'middleware-manifest.json');
    if (!(0, fs_1.existsSync)(middlewarePath)) {
        return null;
    }
    return (0, fs_extra_1.readJson)(middlewarePath);
};
exports.loadMiddlewareManifest = loadMiddlewareManifest;
/**
 * Convert the Next middleware name into a valid Edge Function name
 */
const sanitizeName = (name) => `next_${name.replace(/\W/g, '_')}`;
/**
 * Initialization added to the top of the edge function bundle
 */
const preamble = /* js */ `
import {
  decode as _base64Decode,
} from "https://deno.land/std@0.159.0/encoding/base64.ts";
// Deno defines "window", but naughty libraries think this means it's a browser
delete globalThis.window
globalThis.process = { env: {...Deno.env.toObject(), NEXT_RUNTIME: 'edge', 'NEXT_PRIVATE_MINIMAL_MODE': '1' } }
// Next uses "self" as a function-scoped global-like object
const self = {}
let _ENTRIES = {}

class Response extends globalThis.Response {
  constructor(body, init) {
    super(body, init);
    // Next.js uses this extension to the Headers API implemented by Cloudflare workerd
    this.headers.getAll = (name) => {
      name = name.toLowerCase();
      if (name !== "set-cookie") {
        throw new Error("Headers.getAll is only supported for Set-Cookie");
      }
      return [...this.headers.entries()]
        .filter(([key]) => key === name)
        .map(([, value]) => value);
    };
  }
}


//  Next uses blob: urls to refer to local assets, so we need to intercept these
const _fetch = globalThis.fetch
const fetch = async (url, init) => {
  try {
    if (typeof url === 'object' && url.href?.startsWith('blob:')) {
      const key = url.href.slice(5)
      if (key in _ASSETS) {
        return new Response(_base64Decode(_ASSETS[key]))
      }
    }
    return await _fetch(url, init)
  } catch (error) {
    console.error(error)
    throw error
  }
}

`;
// Slightly different spacing in different versions!
const IMPORT_UNSUPPORTED = [
    `Object.defineProperty(globalThis,"__import_unsupported"`,
    `    Object.defineProperty(globalThis, "__import_unsupported"`,
];
/**
 * Concatenates the Next edge function code with the required chunks and adds an export
 */
const getMiddlewareBundle = async ({ edgeFunctionDefinition, netlifyConfig, }) => {
    const { publish } = netlifyConfig.build;
    const chunks = [preamble];
    if ('wasm' in edgeFunctionDefinition) {
        for (const { name, filePath } of edgeFunctionDefinition.wasm) {
            const wasm = await fs_1.promises.readFile((0, path_1.join)(publish, filePath));
            chunks.push(`const ${name} = _base64Decode(${JSON.stringify(wasm.toString('base64'))}).buffer`);
        }
    }
    if ('assets' in edgeFunctionDefinition) {
        chunks.push(`const _ASSETS = {}`);
        for (const { name, filePath } of edgeFunctionDefinition.assets) {
            const wasm = await fs_1.promises.readFile((0, path_1.join)(publish, filePath));
            chunks.push(`_ASSETS[${JSON.stringify(name)}] = ${JSON.stringify(wasm.toString('base64'))}`);
        }
    }
    for (const file of edgeFunctionDefinition.files) {
        const filePath = (0, path_1.join)(publish, file);
        let data = await fs_1.promises.readFile(filePath, 'utf8');
        // Next defines an immutable global variable, which is fine unless you have more than one in the bundle
        // This adds a check to see if the global is already defined
        data = IMPORT_UNSUPPORTED.reduce((acc, val) => acc.replace(val, `('__import_unsupported' in globalThis)||${val}`), data);
        chunks.push('{', data, '}');
    }
    const exports = /* js */ `export default _ENTRIES["middleware_${edgeFunctionDefinition.name}"].default;`;
    chunks.push(exports);
    return chunks.join('\n');
};
const getEdgeTemplatePath = (file) => (0, path_1.join)(__dirname, '..', '..', 'src', 'templates', 'edge', file);
const copyEdgeSourceFile = ({ file, target, edgeFunctionDir, }) => fs_1.promises.copyFile(getEdgeTemplatePath(file), (0, path_1.join)(edgeFunctionDir, target !== null && target !== void 0 ? target : file));
const writeEdgeFunction = async ({ edgeFunctionDefinition, edgeFunctionRoot, netlifyConfig, nextConfig, }) => {
    const name = sanitizeName(edgeFunctionDefinition.name);
    const edgeFunctionDir = (0, path_1.join)(edgeFunctionRoot, name);
    const bundle = await getMiddlewareBundle({
        edgeFunctionDefinition,
        netlifyConfig,
    });
    await (0, fs_extra_1.ensureDir)(edgeFunctionDir);
    await fs_1.promises.writeFile((0, path_1.join)(edgeFunctionDir, 'bundle.js'), bundle);
    await copyEdgeSourceFile({
        edgeFunctionDir,
        file: 'runtime.ts',
        target: 'index.ts',
    });
    const matchers = [];
    // The v1 middleware manifest has a single regexp, but the v2 has an array of matchers
    if ('regexp' in edgeFunctionDefinition) {
        matchers.push({ regexp: edgeFunctionDefinition.regexp });
    }
    else if (nextConfig.i18n) {
        matchers.push(...edgeFunctionDefinition.matchers.map((matcher) => ({
            ...matcher,
            regexp: (0, matchers_1.makeLocaleOptional)(matcher.regexp),
        })));
    }
    else {
        matchers.push(...edgeFunctionDefinition.matchers);
    }
    await (0, fs_extra_1.writeJson)((0, path_1.join)(edgeFunctionDir, 'matchers.json'), matchers);
    // We add a defintion for each matching path
    return matchers.map((matcher) => {
        const pattern = (0, matchers_1.stripLookahead)(matcher.regexp);
        return { function: name, pattern, name: edgeFunctionDefinition.name };
    });
};
const cleanupEdgeFunctions = ({ INTERNAL_EDGE_FUNCTIONS_SRC = '.netlify/edge-functions', }) => (0, fs_extra_1.emptyDir)(INTERNAL_EDGE_FUNCTIONS_SRC);
exports.cleanupEdgeFunctions = cleanupEdgeFunctions;
const writeDevEdgeFunction = async ({ INTERNAL_EDGE_FUNCTIONS_SRC = '.netlify/edge-functions', }) => {
    const manifest = {
        functions: [
            {
                function: 'next-dev',
                name: 'netlify dev handler',
                path: '/*',
            },
        ],
        version: 1,
    };
    const edgeFunctionRoot = (0, path_1.resolve)(INTERNAL_EDGE_FUNCTIONS_SRC);
    await (0, fs_extra_1.emptyDir)(edgeFunctionRoot);
    await (0, fs_extra_1.writeJson)((0, path_1.join)(edgeFunctionRoot, 'manifest.json'), manifest);
    await (0, fs_extra_1.copy)(getEdgeTemplatePath('../edge-shared'), (0, path_1.join)(edgeFunctionRoot, 'edge-shared'));
    const edgeFunctionDir = (0, path_1.join)(edgeFunctionRoot, 'next-dev');
    await (0, fs_extra_1.ensureDir)(edgeFunctionDir);
    await copyEdgeSourceFile({ edgeFunctionDir, file: 'next-dev.js', target: 'index.js' });
};
exports.writeDevEdgeFunction = writeDevEdgeFunction;
/**
 * Writes Edge Functions for the Next middleware
 */
const writeEdgeFunctions = async (netlifyConfig) => {
    const manifest = {
        functions: [],
        version: 1,
    };
    const edgeFunctionRoot = (0, path_1.resolve)('.netlify', 'edge-functions');
    await (0, fs_extra_1.emptyDir)(edgeFunctionRoot);
    const { publish } = netlifyConfig.build;
    const nextConfigFile = await (0, config_1.getRequiredServerFiles)(publish);
    const nextConfig = nextConfigFile.config;
    await (0, fs_extra_1.copy)(getEdgeTemplatePath('../edge-shared'), (0, path_1.join)(edgeFunctionRoot, 'edge-shared'));
    await (0, fs_extra_1.writeJSON)((0, path_1.join)(edgeFunctionRoot, 'edge-shared', 'nextConfig.json'), nextConfig);
    if (!(0, destr_1.default)(process.env.NEXT_DISABLE_EDGE_IMAGES) &&
        !(0, destr_1.default)(process.env.NEXT_DISABLE_NETLIFY_EDGE) &&
        !(0, destr_1.default)(process.env.DISABLE_IPX)) {
        console.log('Using Netlify Edge Functions for image format detection. Set env var "NEXT_DISABLE_EDGE_IMAGES=true" to disable.');
        const edgeFunctionDir = (0, path_1.join)(edgeFunctionRoot, 'ipx');
        await (0, fs_extra_1.ensureDir)(edgeFunctionDir);
        await copyEdgeSourceFile({ edgeFunctionDir, file: 'ipx.ts', target: 'index.ts' });
        await (0, fs_extra_1.copyFile)((0, path_1.join)('.netlify', 'functions-internal', '_ipx', 'imageconfig.json'), (0, path_1.join)(edgeFunctionDir, 'imageconfig.json'));
        manifest.functions.push({
            function: 'ipx',
            name: 'next/image handler',
            path: '/_next/image*',
        });
    }
    if (!(0, destr_1.default)(process.env.NEXT_DISABLE_NETLIFY_EDGE)) {
        const middlewareManifest = await (0, exports.loadMiddlewareManifest)(netlifyConfig);
        if (!middlewareManifest) {
            console.error("Couldn't find the middleware manifest");
            return;
        }
        let usesEdge = false;
        for (const middleware of middlewareManifest.sortedMiddleware) {
            usesEdge = true;
            const edgeFunctionDefinition = middlewareManifest.middleware[middleware];
            const functionDefinitions = await writeEdgeFunction({
                edgeFunctionDefinition,
                edgeFunctionRoot,
                netlifyConfig,
                nextConfig,
            });
            manifest.functions.push(...functionDefinitions);
        }
        // Older versions of the manifest format don't have the functions field
        // No, the version field was not incremented
        if (typeof middlewareManifest.functions === 'object') {
            for (const edgeFunctionDefinition of Object.values(middlewareManifest.functions)) {
                usesEdge = true;
                const functionDefinitions = await writeEdgeFunction({
                    edgeFunctionDefinition,
                    edgeFunctionRoot,
                    netlifyConfig,
                    nextConfig,
                });
                manifest.functions.push(...functionDefinitions);
            }
        }
        if (usesEdge) {
            console.log((0, outdent_1.outdent) `
        ✨ Deploying middleware and functions to ${(0, chalk_1.greenBright) `Netlify Edge Functions`} ✨
        This feature is in beta. Please share your feedback here: https://ntl.fyi/next-netlify-edge
      `);
        }
    }
    await (0, fs_extra_1.writeJson)((0, path_1.join)(edgeFunctionRoot, 'manifest.json'), manifest);
};
exports.writeEdgeFunctions = writeEdgeFunctions;
/* eslint-enable max-lines */
